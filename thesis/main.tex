\chapter{Generative Diffeomorphic Deformation Models}
Generative models have been successfully applied to a wide range of medical image analysis tasks such as image registration \cite{balakrishnan2019voxelmorph}, segmentation \cite{dong2017automatic} and visual feature attribution \cite{baumgartner2018visual}. Of particular interest are deformation-based models due to their ability to closely model the gradual changes observed in the context in medical imaging.
Additionally, by using \textit{diffeomorphic} deformations, the model can be limited to operations which are smooth, differentiable and invertible and, as a consequence, topology preserving.
%As a consequence, diffeomorphic models are topology preserving and restricted the
Moreover, unlike convolutional models which generally implement a single atomic transformation, diffeomorphic deformations can be interpolated at any intermediate time step, therefore generally resulting in more interpretable outputs.

%This ability can be strengthened further by limiting the model to smooth and invertible operations such as diffeomorphisms, which has the added benefit of generally resulting in more interpretable outputs as well.
%To that end, deformations can be described by diffeomorphisms, that is, functions which are differentiable and invertible, and therefore topology preserving.

%In contrast to the purely convolution approach, which is in essentially a universal function approximator, deformation-based models are constrained to operations that closely match the actual processes observed in human tissue.
%Particularly in the case of MRI data, voxel intensities are relative, deformation better than additional map

In this section, we discuss the general architecture of our model. We first examine the diffeomorphic brain registration model proposed in \cite{balakrishnan2019voxelmorph} \cite{dalca2018unsupervised} followed by a discussion of our adaptations for the generative brain aging task.

\section{Diffeomorphic Image Registration}
\label{chap:voxelmorph}
In medical imaging, deformable image registration tackles the problem of warping one image onto another. More formally, given two scans $x$ and $y$, the aim is to find a deformation function $\Phi$ such that $x \circ \Phi$ is similar to $y$.

\subsection{Voxelmorph} \label{sec:vox}
Dalca et al \cite{dalca2018unsupervised} propose a deep learning architecture to learn such a mapping for 3-dimensional MRI brain data. Formally, given $x$ and $y$ the model generates a stationary velocity field $v$ which defines the deformation ${\Phi : \R^3 \rightarrow \R^3}$ mapping $x$ to $y$ through the ordinary differential equation (ODE)

\begin{equation} \label{eq:voxODE}
	\frac{\partial \Phi^{(t)}}{\partial t} = v(\Phi^{(t)})
\end{equation}

where $\Phi^{(0)} = id$ is the identity transformation and t is time.
The final deformation field $\Phi^{(1)}$ is then obtained by integrating the field $v$ over time $t = [0, 1]$, which is computed numerically using the scaling and squaring method \cite{arsigny2006log}.

In group theory, $v$ is a member of the Lie algebra and is exponentiated to produce $\Phi^{(1)} = \exp(v)$.
The collection $\{\Phi^{(t)}\}_{t \; \in \; [0,1]}$ forms a one-parameter subgroup of diffeomorphisms and therefore for any scalars $t$ and $t'$ we have 
\begin{equation} \label{eq:voxoneparamsubgroup}
	\exp((t + t')v) = \exp(tv) \circ \exp(t'v)
\end{equation}

where $\circ$ is a composition map associated with the Lie group. Consequently, we can then use the recurrence
\begin{equation} \label{eq:voxrecurrence}
	\Phi^{(1/2^{(t-1)})} = \Phi^{(1/2^{t})} \circ \Phi^{(1/2^{t})}
\end{equation}

starting from $\Phi^{(1/2^T)}$ to obtain $\Phi^{(1)} = \Phi^{(1/2)} \circ \Phi^{(1/2)}$ where $T$ is chosen such that $v \approx 0$.

The model uses a variational inference method to generate a stationary displacement field $z$ which defines the deformation $\Phi_z$ through the ODE (\ref{eq:voxODE}). The prior probability of $z$ is modeled as
\begin{equation}
	p(z) = \mathcal{N}(z; 0, \Sigma_z)
\end{equation}

Spatial smoothness of z is is encouraged by letting ${\Sigma_z^{-1} = \Lambda_z = \lambda L}$ where $\Lambda_z$ is a precision matrix, $L$ is the Laplacian of a neighborhood graph defined as $L = D - A$, with graph degree matrix $D$ and voxel adjacency matrix $A$, and $\lambda$ denotes a parameter controlling the scale of the velocity field.

The generator's output is modelled as a gaussian distribution with mean $y$, the target image, and standard deviation $\sigma$. In other words, the warped image $x$ is interpreted as a noisy oberservation of the target image $y$
\begin{equation}
	p(y|z;x) = \mathcal{N}(y; x \circ \Phi_z, \sigma^2 \mathbbm{I})
\end{equation}

with $\sigma^2$ reflecting the variance of the additive noise.

A likely registration field $\Phi_z$ can then obtained by sampling $z$ from the posterior distribution $p(z | x; y)$.
However, computing this distribution is intractable in this setting and hence a variational approach is used where $z$ is sampled from an approximate posterior probability $q_\psi(z | x; y)$ parametrized by $\psi$. The distribution is modeled as a multivariate normal
\begin{equation}
	q_\psi(z | x; y) = \mathcal{N}(z; \mu_{z | x, y}, \Sigma_{z | x, y})
\end{equation}

and approximated by minimizing the KL divergence
\begin{equation}
	\begin{split}
		  &\min_\psi KL [ q_\psi(z | x; y) || p(z | x; y) ] \\
		= &\min_\psi KL [ q_\psi(z | x; y) || p(z) ] - \E_q [ \log p(y | z; x) ]
	\end{split}
\end{equation}

The complete loss function can be separated into two components, a reconstruction and a prior term. Furthermore, the latter can be split into a covariance and a precision term.
\begin{equation} \label{eq:voxloss}
	\begin{split}
		\mathcal{L}(\psi; x, y)
		& = -\E_{q}[ \log p( x | z; y ) ]
		+ \text{KL} [ q_{\psi} ( z | x ; y ) || p ( z ) ] \\[12pt]
		& = \underbrace{
			\frac{1}{2 \sigma^2} \norm{y - x \circ \Phi_{z}}^{2} \vphantom{\frac{1}{2_{2_2}}}
		}_{\text{reconstruction term}} \\[6pt]
		& + \frac{1}{2} \bigg[
		\underbrace{
			tr( \lambda D \Sigma_{z | x; y} - \log \abs{ \Sigma_{z | x; y} } ) \vphantom{\mu_{z | x; y}^{T}}
		}_{\text{covariance term}} +
		\underbrace{
			\mu_{z | x; y}^{T} \Lambda_{z} \mu_{z | x; y}
		}_{\text{precision term}} \bigg]
	\end{split}
\end{equation}

The first term enforces similarity between the target image $y$ and the warped source image $x \circ \Phi_z$, the second term encourages the posterior to be close to the prior $p(z)$ while the third term spatially smoothes the mean $\mu_{z | x, y}$. This effect can be shown more explicitly by rewriting the precision term as $ { \frac{\lambda}{2} \sum \sum_{j \in N(I)} ( \mu[i] - \mu[j])^{2} } $, where $N(i)$ denotes the set of neighbors of voxel $i$. Both $\sigma$ and $\lambda$ are treated as hyperparameters, respectively controlling the reconstruction penalty and the magnitude of the velocity field.

\subsubsection*{Network Architecture}
The paramaters $\mu_{z | x, y}$ and $\Sigma_{z | x, y}$ are estimated by a convolutional neural network (CNN). The architecture, which takes $x$ and $y$ as input, is based on a fully convolutional 3D UNet consisting of a convolutional layer of 16 filters followed by four downsampling layers with strides of two and three upsampling layers of 32 filters each. All convolutional layers use leaky ReLU activations with $\alpha = 0.2$ and kernels of size $3\times3\times3$. See \autoref{fig:archvox} for an illustration of the generator model.

\begin{figure}
	\centering
	\input{tikz/arch_vox}
	\caption{Voxelmorph for diffeomorphic image registration as proposed in \cite{dalca2018unsupervised}. The UNet-based encoder receives both $x$ and $y$ as inputs and approximates the distributon $q_\psi$ from which the velocity field $z$ is sampled. Subsequently, $z$ is integrated using a configurable number of scaling and squaring layers resulting in the final deformation field $\Phi^{(1)}$ which is then applied to the input image $x$.}
	\label{fig:archvox}
\end{figure}

Given $\mu_{z | x, y}$ and $\Sigma_{z | x, y}$, the subsequent layer then samples a new stationary velocity field $ { z_k \sim \mathcal{N}(\mu_{z | x, y}, \Sigma_{z | x, y}) } $ using the reparameterization trick \cite{kingma2013auto}, which is then integrated using scaling and squaring layers newly introduced in \cite{dalca2018unsupervised} to compute $\Phi_{z_k} = \exp(z_k)$. Specifically, one such layer performs a differentiable vector field composition, that is, given vector fields $a$ and $b$, it computes $(a \circ b)(p) = a(b(p))$ for each voxel $p$. Note that linear interpolation is used in $a$ as $b(p)$ generally yields a non-integer location. The recurrence in \autoref{eq:voxrecurrence} is implemented using $T = 7$ of these layers. Finally, a spatial transform layer applies the deformation field $\Phi_{z_k}$ to the source image $x$ to obtain $x \circ \Phi_{z_k}$.

The network is implemented in Keras with a Tensorflow backend and trained end-to-end using the Adam \cite{kingma2014adam} optimizer.

\section{Adaptation for Brain Aging}
\label{sec:ada}
While the tasks of brain registration and generative brain aging may not appear to have much in common superficially, both can be described in terms of learning a deformation function. As such, the approach used in \cite{balakrishnan2019voxelmorph} can be adapted for the brain aging setting. However, while there are simililarites, a number of key differences in the problem settings require modifications to the model design.

Most importantly, the brain registration task as defined in \cite{balakrishnan2019voxelmorph} and described above is an unsupervised learning problem where both the source image $x$ and the target image $y$ are available in the prediction step. Conversely, since the goal of the brain aging task is to predict the future state of $x$, the aged target image $y$ is only available in training and therefore cannot be a part of the model's input.

Furthermore, the learned deformations for the brain aging task can be expected to be much smaller in scale, therefore increasing the relative magnitude of the noise introduced as part of the reconstruction term in \autoref{eq:voxloss}. In turn, this lowers the model's ability to capture subtle changes which may negatively affect its performance in the brain aging setting. While this problem can be addressed by lowering the hyperparameter $\sigma$, this comes at the cost of decreased generalization as the model is forced to produce results which are progressively closer to the target image $y$.

Finally, while intermediate deformations $\Phi^{(t)}$ for time steps $t \notin \{0, 1\}$ are not of primary interest in the brain registration task, the ability to predict a brain image $G(x) = x \circ \Phi_z^{(t)}$ for arbitrary $t$ promises valuable insights into the progression of neurodegenerative diseases as well as the brain's aging process in general.
Furthermore, the ability to train on image pairs over a large range of different time steps is also beneficial as the number of image pairs for any particular fixed $t$ is very limited. Moreover, training on a continuous range of time steps as opposed to a limited number of fixed intervals should result in improved generalization.

\subsection{Adversarial Loss}
% maybe say what we do first, then why?
%First, we replace the reconstruction term of the loss function \ref{eq:voxloss} with an adversarial loss.

As described above, the model input is restricted to the source image $x$ and, without access to $y$, predicting differences between the source $x$ and target $y$ that are not related to aging, such as artifacts introduced during scanning or preprocessing (e.g. skull remnants or misalignment), is virtually impossible. As a consequence, our loss function should be invariant to such changes, yet this is not the case for the reconstruction term. Moreover, the term introduces image noise which can be problematic given the small scale of aging related changes.

%As described above, the model input is restricted to the source image $x$ due to the supervised nature of the brain aging problem. However, without access to $y$, predicting differences between the source $x$ and target $y$ that are not related to aging, such as artifacts induced during scaning or preprocessing (e.g. skull remnants or misalignment), is virtually impossible. As a consequence, our loss function should be invariant to such changes. Moreover, the reconstruction loss term in \autoref{eq:voxloss} considers $y$ to be a noisy observation of $ x \circ \Phi_z $. While this works well for relatively large deformations, aging-related changes are much smaller in scale

Therefore, we opt to replace the reconstruction loss term in \autoref{eq:voxloss} with an adversarial loss component. We realize this by adding a secondary critic network to the architecture which is trained alongside the generator in an adversarial fashion. Effectively, this tranforms the model into a Generative Adversarial Network (GAN) \cite{goodfellow2014generative}.

In the adversarial setting, a generative model $G$ and a discriminative model $D$ are engaged in a minimax game, in which the generator aims to produce outputs that to the discriminator are indistinguishable from samples drawn from a real data distribution $p_{data}$. More formally, a GAN optimizes the objective
\begin{equation}
	\min_G \max_D V(G, D) = \E_{ x \sim p_{data}(x) } [ \: \log{D (x)} \: ] 
	 - \E_{ z \sim p_z(z) } [ \: 1 - \log{D (G(z))}) \: ]
\end{equation}

where $D(x)$ is a probability and $z$ is usually sampled from a latent distribution. However, in the brain aging setting the goal is to transform a source image $x$ in a way that resembles the actual aging process and therefore we get the revised objective
\begin{equation}
	\begin{split}
		\min_G \max_D V(G, D) = \; & \E_{ (x, y, t) \sim p_{data} } [ \: \log{D (x, y, t)}] \: ] \\
		 - & \E_{ (x, t) \sim p_{data} } [ \: 1 - \log{D (x, G(x), t)}) \: ]
	\end{split}
\end{equation}

where the image pair $(x, y)$ and the corresponding age difference $t$ are samples from the real data distribution. Note that in order to avoid the issue of mode collapse, where the generator outputs the same image for all inputs, the discriminator also observes $x$. Furthermore, to enable the discriminator to discern pairs with differing time steps, we additionally pass $t$ as an input. Both $G$ and $D$ are implemented as neural networks which are trained in an alternating fashion. 

We use a variation of the original GAN known as Wasserstein GAN (WGAN) \cite{arjovsky2017wasserstein} in which the discriminator $D$ is replaced by a critic with real-valued outputs instead of probabilities. The critic is limited to the set of 1-Lipschitz functions, which is enforced by imposing a gradient penalty as proposed in \cite{gulrajani2017improved}.

\subsection{Arbitrary Time Step Training and Prediction} \label{sec:adaarbtimestep}
The scaling and squaring method as described in \autoref{chap:voxelmorph} is fixed to one specific time step $t$ determined by the model configuration as well as the training data. As mentioned above, this is not necessarily an issue in the case of image registration but highly undesirable for the brain aging task. Therefore, in this section we propose an extension to the scaling and squaring method enabling integration of the stationary velocity field $v$ to arbitrary time steps $t$. As a result of this modification, our model can predict and be trained on image pairs with arbitrary time steps greatly increasing the available training data as well as its ability to generalize over different time ranges.

One straightforward approach is to abandon the scaling and squaring method in favor of iterative composition
\begin{equation}
	\Phi^{(t)} =
	\underbrace{
		\Phi^{(1 / 2^T)} \, \circ \, \ldots \, \circ \, \Phi^{(1 / 2^T)} \vphantom{\Phi^{(1 / 2^T)}_2}
	}_{\lceil 2^T \times \: t \rceil \ \text{times}}
\end{equation}

where $2^T$ is the scaling factor and $t$ is the desired time step. Given a large enough $T$, this method can handle any positive time step with arbitrary precision, however very quickly at the cost of computional unfeasibility. Similarly, we could use a two step approach, calculating the deformation $\Phi^{(\epsilon)}$ for some time step $\epsilon$ by scaling and squaring, followed by iterative composition of $\Phi^{(\epsilon)}$. While this is much faster in practice, the choice of $\epsilon$ represents a trade-off between precision, data availability and computational viability.

In addition to the final deformation field $\Phi^{(1)}$, the recurrence also yields intermediate deformations $\{ \Phi^{(1 / 2^{t})} \}_{t \; \in \; 1 .. T} $ at no additional computational cost. For instance, the computation of a deformation field corresponding to a time step of 8 years additionally yields the deformations for (and therefore the ability to predict and train on) time steps of ${ 4, 2, 1, \sfrac{1}{2}, \ldots }$ years. While this represents an improvement, the benefits are relatively minor as we are still limited to a small and very specific set of time steps.

However, from the properties of one-parameter subgroups in \autoref{eq:voxoneparamsubgroup} we know that any two given deformations $\Phi^{(t)}$ and $\Phi^{(t')}$ can be composed to obtain ${ \Phi^{(t + t')} = \Phi^{(t)} \circ \Phi^{(t')} }$. It follows that for any time step $t \in [0, 1)$, the corresponding deformation $\Phi^{(t)}$ can be approximated to within a temporal precision factor $\epsilon$ by composing deformations from a subset $\mathcal{S}^{(t)} \subset \{ \Phi^{(1 / 2^{t})} \}_{t \; \in \; 1 .. T} $ of intermediate deformations
\begin{equation}
	\Phi^{(t)} = \underset{\Phi^{(i)} \; \in \; \mathcal{S}^{(t)}}{\bigcirc} \Phi^{(i)}
\end{equation}

In other words, $\{ \Phi^{(1 / 2^{s})} \}_{s \; \in \; 1 .. T}$ can be interpreted as a set of vectors that span the space of all deformations $\Phi^{(t)}$ for $t \in [0, 1)$, where each $\Phi^{(t)}$ is uniquely represented by a binary vector in this space. Intuitively speaking, this is analogous to how any positive integer can be expressed in $base_2$ as the sum over a set of powers of 2. The deformation is computed iteratively over all squaring steps as laid out in \autoref{alg:arbtimestep}. Refer to \autoref{fig:arbtimestep} for a visual example of one such composition.

The temporal precision $\epsilon$, i.e. the smallest difference in time steps representable by the model, is determined by the number of squaring steps $T$ as well as the maximum time step $t_{max}$ used during training. Specifically, $\epsilon$ is the time step corresponding to the smallest deformation field $\Phi^{(\sfrac{1}{2^T})} = \sfrac{v}{2^T}$ and therefore $\epsilon = \sfrac{t_{max}}{2^T}$. For instance, given $t_{max} = 6$ years and $T = 7$, $\epsilon = 0.046$ years or approximately $17$ days.

In practice, the efficiency of the computation can be improved by computing only the intermediate deformations up to the largest step required for the composition of $\Phi^{(t)}$. Note also that predictions for time steps $t > 1$ can be generated by dynamically increasing the number of squaring layers during inference.

\input{algo/timestep}

\begin{figure}
	\centering
	\input{tikz/timestep}
	\caption{Arbitrary time step scaling and squaring with $T = 2$ squaring and $ 2^{T+1} = 8 $ atomic steps, shown for one voxel $ \vec p $. The deformation $ \Phi^{(t)} $ can be approximated at any time step $ t \in [0, 1] $ by composing a subset of intermediate deformations. Note that in practice, larger $T$ are used resulting in an exponentially higher number of atomic steps and therefore a better approximation, e.g. $T = 7$ yielding $ 2^8 = 256 $ atomic steps. We calculate the deformation for all voxels $ \vec{p} $ in parallel.} \label{fig:arbtimestep}
\end{figure}

\subsection{Additional Loss Terms}
In addition to the adversarial loss we also examine four additional loss terms and their effects on the model performance.

\subsubsection*{Age Regressor}
\label{sec:adaagereg}
While the diffeomorphic approach encourages the model to generate realistically aged $G(x) = x \circ \Phi^{(t)}$ with respect to time step $t$, we strengthen this further by using a pre-trained age regressor $R$ to estimate the apparent age of $G(x)$. In this setting, $R$ is a model which estimates a patient's age based on an MRI scan of their brain.
Let $ a_x $ denote a patient's age at the time of taking image $x$ and $ \hat a_x = R(x)$ denote the age as estimated by the age regressor on $x$. As a side note, for the generator we generally assume $t \in [0, 1]$ normalized by $\max_{(x, y) \in \mathcal{D}_{train}} a_y - a_x $, the maximum time step occuring in the training data, and therefore $t_{(x, y)} \neq a_y - a_x$ in general.

We consider two different possible loss terms 
\begin{equation}
	\begin{split}
		(1) \quad \mathcal{L}_{age}(x, y, R) & = 
		| (a_y - a_x) - (\hat a_{G(x)} - a_x) | =
		| a_y - \hat a_{G(x)} | \\[8pt]
		(2) \quad \mathcal{L}_{age}(x, y, R) & =
		| (\hat a_y - \hat a_x) - (\hat a_{G(x)} - \hat a_x) | = 
		| \hat a_y - \hat a_{G(x)} |
	\end{split}
\end{equation}

with $(1)$ using ground truth labels whenever available and $(2)$ using the regressor throughout. We hypothesize (2) to be superior due to inaccuracies of the age regressor cancelling out. This assumption is supported by our experimental results in \autoref{sec:expagereg} and consequently, we use (2) for our model.

\subsubsection*{Diagnosis Classifier}
Similar to the age regressor, we also add a loss term based on a diagnosis classifier $C$ to encourage the model to understand and distinguish between different diagnoses. Let $d_x$ denote the ground truth diagnosis label assigned to $x$ (with 0 = MCI, 1 = AD) and $\hat d_x$ denote the classifier's estimated probability of the brain in image $x$ being affected by AD. As before, we examine two possible cross entropy loss terms between ground truth labels and the estimated probabilities respectively and implement $(2)$, following the same reasoning used in selecting the age regressor loss term.

\begin{equation}
	\begin{split}
		H(p, q) & = -p \log\, q - (1 - p)\log(1 - q) \\[8pt]
		(1) \quad \mathcal{L}_{dx}(x, y, C) & = 
		H(d_y, \hat d_{G(x)}) \\[8pt]
		(2) \quad \mathcal{L}_{dx}(x, y, C) & =
		H(\hat d_y, \hat d_{G(x)}) \\[8pt]
	\end{split}
\end{equation}

In addition to its use in this loss term, the classifier also serves as our baseline for the conversion prediction experiment as described in \autoref{sec:appconvpred}.

\subsubsection*{Similarity Loss}
Similar to \cite{baumgartner2018visual} and \cite{wegmayr2019generative}, we introduce an additional loss term intended to prevent the model from introducing drastic changes between the original image $x$ and the warped image $ x \circ \Phi^{(t)} $ by imposing an $L_1$ loss on their difference
\begin{equation}
	\mathcal{L}_{sim}( x, G ) = \norm{ x - G(x) }_1
\end{equation}

Note that we choose not to scale the similarity loss with respect to time step $t$. This is based on the observation that while the $L_1$ difference does increase for larger $t$, as depicted in \autoref{fig:l1plots}, it does so rather slowly, indicating that the difference is primarily caused by differences not related to aging. As a side note, the weak correlation between the $L_1$ difference and time step $t$ also indicates that the metric is not well suited to validate our the aging performance of our generative model.

\subsubsection*{Sparseness Loss}
Finally, we encourage sparseness of the velocity field by imposing an $L_1$ loss on its magnitude
\begin{equation}
	\mathcal{L}_{sparse}( x, G ) = \norm{\mu_z}_1
\end{equation}

Note that while this loss term acts as a regularizer, the primary motivation for sparseness is to improve the interpretability of the deformation field by discouraging displacements with very little or no effect at all.

\subsubsection*{Complete Objective}
To summarize, we obtain the complete objective for the generator as follows

\begin{equation}
	\mathcal{L}_G =
		\mathcal{L}_{ws} +
		\lambda_{1} \; \mathcal{L}_{kl} +
		\lambda_{2} \; \mathcal{L}_{age} + 
		\lambda_{3} \; \mathcal{L}_{dx} + 
		\lambda_{4} \; \mathcal{L}_{sim} + 
		\lambda_{5} \; \mathcal{L}_{sparse}
\end{equation}

where $\mathcal{L}_{ws}$ is the generator's component of the Wasserstein loss function and $\mathcal{L}_{kl}$ consists of the covariance and precision terms from \autoref{eq:voxloss}. Furthermore, we treat $ \{ \lambda_i \}_{i\;\in\;1\;..\;5}$ as hyperparameters.

\subsection{Network Architecture}
Based on architectures applied to similar problems such as \cite{wegmayr2019generative} and \cite{baumgartner2018visual}, we expect the brain aging problem to be a more difficult task compared to brain registration as implemented in Voxelmorph. Therefore, we significantly increase the complexity of the UNet model as shown in \autoref{fig:archour}.
%Furthermore, for computational reasons, we generate the velocity and intermediate deformation fields in half-size and upsample the final displacement to full-size before applying it to the input image $x$. Finally,
Moreover, we experiment with a low resolution time-invariant deformation component, extracted from the UNet, to capture differences that are independent of time step $t$ such as misalignments introduced during scanning or preprocessing. More specifically, we fork the UNet's decoder into two distinct paths and bypass the scaling and squaring layers for one of them, resulting in two deformation maps to be applied to the input image $x$. Separating the deformation into two components is desirable as it allows ignoring changes independent of time and therefore aging during inference on unseen data.
However, in preliminary experiments, this component appears to overpower the time-dependent deformations resulting in poor model performance and, as a consequence, is not included in our final model architecture.

\begin{figure}
	\centering
	\input{tikz/arch_our}
	\caption{Overview of our generator and critic network architectures. The outputs of the squaring layers are applied selectively depending on the value of $t$. In the critic, depending on the step of the GAN training procedure, input $y$ is either a real or a generated image.}
	\label{fig:archour}
\end{figure}

\chapter{Applications}
Our primary goal is to design a generative model $G$ capable of learning and simulating the aging process of the brain. Given an input image $x$, we can then use the trained model $G$ to generate a predicted future state of the brain $\hat y^{(t)} = G(x) = x \circ \Phi^{(t)}$ for any time step $t$.

As shown by \cite{wegmayr2019generative}, the ability to generate realistic predictions is beneficial in the early detection of Alzheimer's Disease onset. Generative models are of particular interest since existing diagnostic tools, such as diagnosis classifiers operating on MRI scan, can be directly applied to predictions $\hat y$ without any necessary adaptations. Furthermore, the resulting deformation fields may yield insights into the progression and specific changes of neurodegenerative diseases.

\section{Conversion Prediction} \label{sec:appconvpred}
Early prediction of Alzheimer's Disease onset is an important area of Alz-heimer's research, with one particular interest being the Mild Cognitive Impairment (MCI) conversion problem. Given data about a patient diagnosed with MCI at some visit $v_i$, our goal is to predict the probabilty of that patient's diagnosis converting to AD over a given period of time $ \Delta $. 
In this context, we distinguish between progressive cases (pMCI) for which the diagnosis converts within $\Delta$, and stable cases (sMCI) for which it does not.

More specifically, a case is considered \textit{progressive} if there exists a pair of visits $(v_a, v_b)$ at times $(t_a, t_b)$ with $ t_b - t_a \geq \Delta $ and diagnoses $d_a = \text{MCI} $ and $d_b = \text{AD} $. Moreover, we require that the diagnosis does not revert after $v_b$, that is $ d_i = \text{AD} $ for all visits $v_i$ with $t_i > t_b$.

Conversely, a case is considered \textit{stable} if its diagnosis does not change across the entire data set and its visits span a time frame of at least $\Delta$, that is $ d_i = \text{MCI} $ for all visits $v_i$ and $ { \max_{v_i \in V(s)} t_i -  \min_{v_i \in V(s)} t_i \geq \Delta } $, where $V(s)$ is the set of visits of subject $s$.

Using our model, we can generate $\hat y^{(\Delta)} = x \circ \Phi^{(\Delta)}$ and use this prediction to estimate the probability of a conversion occuring.

\section{Long-Term Prediction}
\label{sec:applongterm}
Another interesting application is to generate predictions for larger time steps. While we don't expect the model's predictions to be particulary accurate in this setting, especially for time steps $t \gg 1$, i.e. time steps significantly exceeding the maximum time step occuring in training phase, long-term predictions can be helpful in highlighting areas of significant change as well as in visualizing how the aging process of a healthy brain differs from that of a brain affected by AD. Since every additional squaring layer doubles the maximum time step $t$ for which we can generate an image, our model can produce outputs for very large steps at little additional computational cost.

\section{Feature Attribution}
Finally, similar to \cite{baumgartner2018visual}, our generator has potential applications in the area of visual feature attribution, that is, highlighting the parts of an image which are most strongly correlated to one of its labels, e.g. the subject's diagnosis TODO(can we say this? Does this make sense?).
For instance, by training the model on different subsets of our data, such as exclusively AD or HC cases, we can model the different progressions and visualize their effects either on a single image or aggregated over subsets of our data.
Finally, since our model is probabilistic, multiple different predictions for the same input image $x$ can be generated, which helps in getting an understanding of our model's uncertainty.

\chapter{Data}

\section{Synthetic Data}
\label{sec:datsynth}
In order to validate our architecture, we first train and evaluate our model on a synthetic data set designed to yield easily interpretable results while still being similar in structure to the preprocessed brain data.

Each sample consists of a pair $(x_i, y_i)$ of $ 80 \times 96 \times 80 $ images, containing a spherical shell with a value of $-1$ on its shell and $1$ in its interior. We randomize both the sphere's radius and position within the image, and sample $t_i \sim \mathcal{U}(0, 1)$, the time step between $x_i$ and $y_i$. The shell's thickness decreases from $x_i$ to $y_i$, where the thickness in $y_i$ is defined as $d_{y_i} = (1-t) d_x$, with $d_x$ identical for all $x_i$. We explore two different backgrounds, a constant value of 0 as well as smoothed gaussian noise identical for $x_i$ and $y_i$ as shown in \autoref{fig:toydata}.

We generate a total of 10'000 samples, using 60\% of the data set for training and 20\% for validation and testing each.

\section{MRI Data}
To train and validate our brain aging models, we use T1-weighted 3D MRI brain scans. We obtain a large data set of raw images with corresponding subject and image meta data from publically available sources and apply a preprocessing pipeline in order to extract, align and segment the brain tissue. Finally, we generate multiple different data sets tailored to our specific experiments.

\subsection{Data Sources}
We use a data set consisting of 19'480 brain MRI scans obtained from the publicly available Alzheimer's Disease Neuroimaging Initiative (ADNI) \cite{jack2008alzheimer} and Australian Imaging Biomarkers and Lifestyle (AIBL) \cite{ellis2009australian} studies. The study data was collected on a total of 9976 visits over a time period of 15 years involving 2794 subjects.

The dimensions of the raw scans depend on the type and model of scanner used and therefore vary slightly, with a median of $ 240 \times 256 \times 170 $. Furthermore, depending on a subject's study group assignment, images are taken at a field strengths of 1.5T or 3T.

\subsection{Image Data Preprocessing}
Our data processing pipeline consists of three primary steps:

\begin{itemize}
\item Registration
\item Extraction
\item Segmentation
\end{itemize}

Firstly, in the registration step we align the raw images to a common reference atlas\footnote{Reference: MNI152\_T1\_1mm} using linear transformations with 12 degrees of freedom. Secondly, we extract the brain from from the surrounding non-brain tissue in what is known as skull stripping or alternatively brain extraction. Both steps are performed utilizing the FSL toolkit \cite{jenkinson2012fsl}, using the \texttt{flirt} \cite{jenkinson2001global} \cite{jenkinson2002improved} and \texttt{bet}\footnote{Parameters: \texttt{-v -f 0.3 -g -0.1}} \cite{smith2002fast} \cite{jenkinson2005bet2} commands respectively. Thirdly, we segment each voxel into one of three classes, White Matter (WM), Gray Matter (GM) and Cerebrospinal Fluid (CSF) while simultaneously correcting a scanner-related image artifact known as the bias field using FSL's \texttt{fast}\footnote{Parameters: \texttt{-t 1 -n 3 -l 20 -I 4 -O 4 -B}} \cite{zhang2001segmentation} command. The results of this operation are three voxel-wise probability maps for the different classes and we then proceed to subtract the WM map from the GM map while dropping the CSM map. This results in a new image with a number of potentially benefitial properties, where all voxel values are restricted to the range [-1, 1] and can be directly compared across different images as shown in \cite{de2018clinically}. Note that the MR imaging process captures relative intensity differences and as a consequence, direct comparison of absolute values is in general not possible for raw or even unit gaussian normalized data. Furthermore, the operation enhances the structural contrast and removes low level variance in the image. We choose this approach based on the assumption, that most of the information relevant to the brain aging process is contained in the structural changes of the segmentation, with smaller differences in intensity most likely representing noise. \autoref{fig:preproc} shows the entire preprocessing pipeline and all its intermediate steps applied to one sample from our data set.

%TODO(experiment comparing restore vs. diff images)

\begin{figure}
	\noindent\makebox[1.1\textwidth]{
		\centering
		\input{tikz/preproc}
	}
	\caption{Preprocessing pipeline visualized for one sample}
	\label{fig:preproc}
\end{figure}

Note that since the primary output of our preprocessing pipeline is based entirely on segmentation masks, one could combine the T1-weighted scans with data from different brain imaging modalities such as T2-weighted MRI data or proton density (PD) scans, therefore drastically increasing the number of possible data sources. However, we do not validate or pursue this idea in the context of this thesis.

For computational reasons, we also perform downsampling with a factor of 0.5 followed by cropping to keep only the center 32 coronal slices, resulting in a final shape of $ 80 \times 32 \times 80 $. However, note that our architecture uses 3D convolutions throughout and therefore can be trained on the full-size data if desired, albeit at a significant computational penalty.

\subsection{Data Splitting} \label{sec:dat}
In order to run our experiments, we generate a number of data sets for the different settings. For the sake of notational brevity and conciseness, let $s$ denote one subject in our data set and let $v^s_i$ denote the $i$-th visit of subject s, with $V(s)$ denoting the temporally ordered set of visits $v^s_i \in V(s)$ of subject $s$, for $i \in 1 \ ..\ |V(s)|$. To improve readability, we generally omit $s$ unless required. For redundancy, MRI scans are usually performed twice resulting in two separate but very similar images for the same visit. Moreover, images taken at different magnetic field strength levels are available for some subjects. As a consequence, a visit $v_i$ typically consists of multiple images $x_{i, k} \in I(v_i)$ along with the corresponding image meta data. Finally, the examdate $t_i$ and the subject age $a_i$ at time $t_i$ as well as the diagnosis $d_i$ are available for most visits.

Our data sets are divided into five equal splits $ \{ \mathcal{S}_i \}_{i\ \in\ 0\;..\;4} $ of 20\% each which are used in various different configurations detailed in the corresponding experiment's section. We perform this split on a subject basis and do so globally, in the sense that if a subject appears in a specific data set, it is always assigned to the same split. In other words, for any pair of splits $ \mathcal{S}_i^A $ and $ \mathcal{S}_j^B $ taken from data sets $A$ and $B$, e.g. pairs and single images, with $ i \neq j $, the intersection $ { \mathcal{S}_i^A \cap \mathcal{S}_j^B = \varnothing } $ is guaranteed to be empty. In addition to these five splits, we keep a separate $\mathcal{S}_{conv}$ containing all images of subjects which are contained in the MCI conversion data set explained below.

\subsubsection*{Base Image Set} \label{sec:datsingles}
The \textit{Base Image Set} forms the foundation for all other data sets. It consists of all images $x_{i, k}$ and the meta data for the corresponding visits $v_i$ for which $t_i$ and $a_i$ are obtainable. The primary use for this set is in the training of our age regressor models.

\begin{table}[h]
	\begin{center}
		\begin{tabular}{c c c c c c c c c c c}
			\toprule
			\multirow{2}{*}{\bfseries Split} & 
			\multirow{2}{*}{\bfseries N} & 
			\multirow{2}{*}{\bfseries S} & 
			\multicolumn{2}{c}{\bfseries HC} & 
			\multicolumn{2}{c}{\bfseries MCI} & 
			\multicolumn{2}{c}{\bfseries AD} &
			\multicolumn{2}{c}{\bfseries Age} \\
			\cmidrule(lr){4-5}
			\cmidrule(lr){6-7}
			\cmidrule(lr){8-9}
			\cmidrule(lr){10-11} 
			& & & N & S & N & S & N & S & mean & std \\ 
			%------
			\cmidrule(lr){1-11}
			$\mathcal{S}_0$      &  2944 &  503 & 1286 &  274 &  961 &  172 &  697 & 137 & 75.1 & 7.4 \\
			$\mathcal{S}_1$      &  2905 &  504 & 1198 &  266 & 1018 &  181 &  689 & 139 & 75.6 & 7.2 \\
			$\mathcal{S}_2$      &  3202 &  506 & 1435 &  269 & 1036 &  178 &  731 & 132 & 76.3 & 7.4 \\
			$\mathcal{S}_3$      &  3294 &  504 & 1563 &  256 & 1025 &  192 &  706 & 136 & 75.6 & 7.4 \\
			$\mathcal{S}_4$      &  2947 &  506 & 1242 &  264 &  992 &  189 &  713 & 147 & 75.1 & 7.6 \\
			$\mathcal{S}_{conv}$ &  4188 &  271 &  174 &   14 & 3184 &  271 &  830 &  98 & 75.2 & 7.1 \\
			\cmidrule(lr){1-11}
			All             & 19480 & 2794 & 6898 & 1343 & 8216 & 1183 & 4366 & 789 & 75.5 & 7.4 \\
			\bottomrule
		\end{tabular}
		\caption{Overview of the base image set. $N$ refers to the number of separate images and $S$ to the number of distinct subjects. Note that for any split, the sum of subjects over all diagnoses generally exceeds the total number of subjects, since one subject may have images with different diagnoses.}
		\label{tab:baseset}
	\end{center}
\end{table}

\subsubsection*{MCI/AD Set} \label{sec:datmciad}
The \textit{MCI/AD Set} consists of the images of all visits $v^s_i$ for which the diagnosis $d^s_i \in \{MCI, AD\}$ and we have high confidence in the label, defined as follows:

We consider a visit $v^s_i$ \textit{firmly MCI} if $d^s_i$ as well as both the diagnoses of the previous and following visit $d^s_{i-1}$ and $d^s_{i+1}$ are $MCI$. Implicitly, this also means that we only consider subjects with at least three visits.

Conversely, for a visit $v^s_i$ to be considered \textit{firmly AD}, we require that both $d^s_i$ and $d^s_{i-1}$, the current and previous diagnoses, are $AD$.

Note that following these definitions, it is possible for one subject to have visits in both the MCI \textit{and} AD group, see \autoref{fig:mciad} for an illustrated example. An overview of the data set is shown in \autoref{tab:mciadset}.

\begin{figure}[h]
	\centering
	\input{tikz/mciad}
	\caption{Illustation of MCI and AD visits, \Large$\circ$\normalsize\;= MCI, $\times$ = AD}
	\label{fig:mciad}
\end{figure}

\vspace{20pt}

\begin{table}[p]
	\begin{center}
		\begin{tabular}{c c c c c c c c c c c}
			\toprule
			\multirow{2}{*}{\bfseries Split} & 
			\multirow{2}{*}{\bfseries N} & 
			\multirow{2}{*}{\bfseries S} & 
			\multicolumn{2}{c}{\bfseries MCI} & 
			\multicolumn{2}{c}{\bfseries AD} & 
			\multicolumn{2}{c}{\bfseries MCI $\cap$ AD} &
			\multicolumn{2}{c}{\bfseries Age} \\
			\cmidrule(lr){4-5}
			\cmidrule(lr){6-7}
			\cmidrule(lr){8-9}
			\cmidrule(lr){10-11} 
			& & & N & S & N & S & N & S & mean & std \\ 
			%------
			\cmidrule(lr){1-11}
			$\mathcal{S}_0$ &  787 & 148 &  391 &  82 &  396 &  71 &  40 &  5 & 74.4 & 7.6 \\
			$\mathcal{S}_1$ &  814 & 148 &  408 &  85 &  406 &  71 &  71 &  8 & 76.4 & 7.9 \\
			$\mathcal{S}_2$ &  909 & 150 &  451 &  82 &  458 &  72 &  45 &  4 & 77.0 & 7.9 \\
			$\mathcal{S}_3$ &  845 & 148 &  426 &  83 &  419 &  71 &  75 &  6 & 76.0 & 7.9 \\
			$\mathcal{S}_4$ &  767 & 150 &  372 &  89 &  395 &  72 &  90 & 11 & 74.9 & 8.0 \\
			\cmidrule(lr){1-11}
			All             & 4122 & 744 & 2048 & 421 & 2047 & 357 & 321 & 34 & 75.8 & 7.9 \\
			\bottomrule
		\end{tabular}
		\caption{Overview of the MCI/AD data set. $N$ refers to the number of separate images and $S$ to the number of distinct subjects. For MCI $\cap$ AD, $N$ refers to the number of images from subjects for which we have images in both groups.}
		\label{tab:mciadset}
	\end{center}
\end{table}

\subsubsection*{Image Pairs Set} \label{sec:datpairs}
The \textit{Image Pairs Set} consists of pairs of images $(x_i, x_j)$ of subject $s$ at two different visits $v_i$ and $v_j$. Of particular importance is the time step $t_j - t_i$ between $v_i$ and $v_j$. We limit the maximum time step to 6 years for computational reasons explained in \autoref{sec:adaarbtimestep}. As visualized in \autoref{fig:timestephist}, the data set is biased towards smaller time steps with median of $1.53$, mean of $2.00$ and a standard deviation of $1.47$ years. To mitigate this, we calculate sample weights $w = {(| t - \bar t | + 1)}^{\sfrac{1}{2}}$, where $\bar t$ is the mean over all time steps $t$. The resulting distribution is shown in \autoref{fig:timestephist}. We also visualize the $L_1$ difference between $x$ and $y$ for all pairs in \autoref{fig:l1plots}.

\begin{table}[p]
	\begin{center}
		\begin{tabular}{l c c | c c c c c c}
			\toprule
			& 
			\multicolumn{2}{c}{All} &
			\multicolumn{2}{c}{\bfseries HC} & 
			\multicolumn{2}{c}{\bfseries MCI} & 
			\multicolumn{2}{c}{\bfseries AD} \\
			\cmidrule(lr){2-3}
			\cmidrule(lr){4-5}
			\cmidrule(lr){6-7}
			\cmidrule(lr){8-9}
			& N & \multicolumn{1}{c}{S} & N & S & N & S & N & S \\ 
			\cmidrule(lr){1-9}
			%------
			\bfseries HC  &  7339 &  674 & 6739 & 649 &  495 & 110 &  105 &  27 \\
			\bfseries MCI &  5399 &  918 &  469 &  83 & 3698 & 737 & 1232 & 331 \\
			\bfseries AD  &  2019 &  421 &    1 &   1 &   43 &  18 & 1975 & 416 \\
			\cmidrule(lr){1-9}
			All           & 14757 & 1789 & 7209 & 673 & 4236 & 794 & 3312 & 646 \\
			\bottomrule
		\end{tabular}
		\caption{Overview of the image pairs set, showing the number of pairs for all combinations of diagnoses. Rows correspond to the first image, columns to the second. $N$ refers to the number of separate images and $S$ to the number of distinct subjects.}
		\label{tab:pairsset}
	\end{center}
\end{table}

\begin{figure}[h]
	\centering
	\begin{subfigure}{0.48\textwidth}
		\includegraphics[width=\linewidth, trim={10 30 30 30}, clip]{images/l1_diff_plots/brains} 
		\caption{full-size}
	\end{subfigure}
	\begin{subfigure}{0.48\textwidth}
		\includegraphics[width=\linewidth, trim={10 30 30 30}, clip]{images/l1_diff_plots/slice.pdf}
		\caption{cropped}
	\end{subfigure}
	 
	\caption{$L_1$ difference between image pairs $(x, y)$ from our data set for both the full-size and the cropped scans. While the difference increases with $t$, it does so rather slowly with slopes of 0.007 and 0.011 respectively.}
	\label{fig:l1plots}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{images/timestep_plots/hist} 
	\caption{The histogram for time step $t$ across all pairs in the pairs data set. To mitigate the bias towards smaller $t$, we calculate sample weights to be used during training of the generator model.}
	\label{fig:timestephist}
\end{figure}


\subsubsection*{MCI Conversion Set} \label{sec:datconv}
The \textit{MCI Conversion Set} consists of image pairs $(x_i, x_j)$ of progressive and stable MCI subjects according to the definitions in \autoref{sec:appconvpred}. Adding to these constraints, for a subject to be considered pMCI we further require a minimum of two visits diagnosed as MCI and AD each. Furthermore, the subject's diagnosis may not revert from AD to MCI at any point in time.

Following the notation in \ref{sec:appconvpred}, we choose the time step between $v_i$ and $v_j$ to be $\Delta = 4$ based on the available data as well as previous work in \cite{wegmayr2019generative}. In general, multiple viable image pair combinations exist for each subject. We prioritize matching $\Delta$ followed by centering the point in time where the diagnosis change occurs within $\Delta$. \autoref{fig:pmci} shows one such pair of visits for a pMCI subject. In total, the conversion set contains 271 pairs of images from 271 subjects, of which 98 are pMCI and 173 are sMCI.

\begin{figure}[h]
	\centering
	\input{tikz/pmci}
	\caption{Illustration of a pMCI image pair, \Large$\circ$\normalsize\;= MCI, $\times$ = AD}
	\label{fig:pmci}
\end{figure}

Note that due to its use in the model validation, this data set represents a separate independent split, that is, subjects which are part of the MCI Conversion Set do not occur in any other split.
\begin{comment}
\subsubsection*{Leave One Visit Out} \label{sec:datloo}
Finally, as the name implies, the \textit{Leave One Visit Out Set} is formed by assigning one visit $v^s_i \in V(s)$ at random to the validation set for all subjects $s$ with $ | V(s) | \ge 3 $. All remaining visits are placed in the training set. Note that due to these criteria, this data set does not follow the global 5-fold split. See \autoref{tab:looset} for an overview of the data set.

\begin{table}[p]
	\begin{center}
		\begin{tabular}{c c c c c c c c c c c}
			\toprule
			\multirow{2}{*}{\bfseries Split} & 
			\multirow{2}{*}{\bfseries N} & 
			\multirow{2}{*}{\bfseries S} & 
			\multicolumn{2}{c}{\bfseries HC} & 
			\multicolumn{2}{c}{\bfseries MCI} & 
			\multicolumn{2}{c}{\bfseries AD} &
			\multicolumn{2}{c}{\bfseries Age} \\
			\cmidrule(lr){4-5}
			\cmidrule(lr){6-7}
			\cmidrule(lr){8-9}
			\cmidrule(lr){10-11} 
			& & & N & S & N & S & N & S & mean & std \\ 
			%------
			\cmidrule(lr){1-11}
			$\mathcal{S}_{train}$ & 16240 & 2794 & 5867 & 1338 & 6834 & 1164 & 3539 & 767 & 75.5 & 7.4 \\
			$\mathcal{S}_{valid}$ &  1599 & 1599 &  544 &  544 &  666 &  666 &  389 & 389 & 75.3 & 7.3 \\
			\cmidrule(lr){1-11}
			All                   & 17839 & 2794 & 6411 & 1343 & 7500 & 1183 & 3928 & 789 & 75.5 & 7.4 \\
			\bottomrule
		\end{tabular}
		\caption{Overview of the Leave One Visit Out data set. $N$ refers to the number of separate images and $S$ to the number of distinct subjects.}
		\label{tab:looset}
	\end{center}
\end{table}

\end{comment}

\chapter{Experiments}

\section{Age Regressor} \label{sec:expagereg}
Validating the performance of a generative model is a hard problem in general. Beyond visual inspection of the outputs, we also obtain an estimation of the age label, and by extension the time step, by applying a pre-trained age regressor to our model's outputs. Furthermore, the regressor is also included in the generator loss function as described in \autoref{sec:adaagereg}. Given its importance in the validation of our generative model, we evaluate the regressor's performance on a number of different tasks.

The regressor is implemented as a 3D CNN with nine layers of which eight use batch normalization, and trained using the Adam optimizer with $\alpha = 0.001, \beta_1 = 0.9, \beta_2 = 0.999 $ and $ \epsilon = 0.0001 $.

\subsection*{Absolute Error}
First, we train the regressor for 30'000 batches of 32 samples each optimizing the absolute mean error as its objective function. Using our 5-fold data split, we perform cross validation and present the results in \autoref{tab:resagecrossval}. \autoref{fig:regxrxrhat} shows the estimated age $ \hat a_x $ against the ground truth label $a_x$ for one validation split. We note that the estimator tends to the mean, that is, its estimates are most accurate around the mean age across the data set of 75 years, and are low for subjects above the mean and high for subjects below the mean. Given the linear nature of the loss function, this is to be expected.

However, in our generative model, rather than estimating the absolute age of an image, the age regressor is used to estimate the relative age difference $a_y - a_x$ for an image pair $(x, y)$. Therefore, we further evaluate its performance on this task using our data set of image pairs. As before, we perform 5-fold cross validation and report the results in \autoref{tab:regcrossval}. \autoref{fig:regxryr} compares the absolute losses for $x$ and $y$ and shows the error cancelling effect discussed in \autoref{sec:adaagereg}. Furthermore, we also estimate the age difference as $\hat a_y - \hat a_x$ for one split and visualize it against the ground truth time step in \autoref{fig:regddhatreal}. Using linear regression on our data points, we obtain an intercept of 0.03 and a slope of 0.67, indicating the estimated age difference tends to be too small for increasing $t$. This can be explained by closer examination of \autoref{fig:regxrxrhat} which shows that as the estimate $\hat a_x$ tends to the mean for labels futher away from it, relative age differences are subject to a shrinkage effect. 

Note that since we are performing these experiments on real image pairs, the results represent an upper bound for the performance of our generative model.
%TODO(crossval)

\begin{figure}
	\centering
	\includegraphics[width=.9\linewidth]{images/age_plots/xr_xrhat} 
	\vspace*{-15pt}
	\caption{Age regressor estimates on 2937 validation samples from our base image data set. Note how the predicitions tend to the mean, with a slope of 0.58 compared to the target of 1. The subject's diagnosis does not appear to have a major impact on the performance.}
	\label{fig:regxrxrhat}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=.9\linewidth]{images/age_plots/xr_yr_dx} 
	\vspace*{-15pt}
	\caption{Age regressor estimates on 2651 validation samples from our pairs data set, with each axis representing one of the two images. While the absolute age error for a single image is quite significant with a mean of 3.39, the estimate of the relative age difference between two images from the same subject is considerably more accurate with a mean error of 1.21.}
	\label{fig:regxryr}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=.7\linewidth]{images/age_plots/d_dhat_real}
	\vspace*{-15pt}
	\caption{Age regressor estimates on 2651 validation samples from our pairs data set, comparing the estimated age difference to the ground truth time step. Linear regression yields an intercept of 0.03 and a slope of 0.67. Note that the stripe patterns forming along the $x$-axis are a consequence of the study scheduling which mandates follow-up visits in intervals of six or twelve months.}
	\label{fig:regddhatreal}
\end{figure}

\subsection*{Squared Error}
We also examine the performance of the same architecture optimizing the mean squared error, with very similar results presented in \autoref{tab:regcrossval}

\begin{table}[h]
	\begin{center}
		\begin{tabular}{c c c c c}
			\toprule
			\multirow{2}{*}{Split} & 
			\multicolumn{2}{c}{absolute} & 
			\multicolumn{2}{c}{squared} \\
			\cmidrule(lr){2-3}
			\cmidrule(lr){4-5}
			 & $\mu$ & $\sigma$ & $\mu$ & $\sigma$ \\ 
			%------
			\cmidrule(lr){1-5}
			$\mathcal{S}_0$ & 3.58 & 2.92 & 3.62 & 2.96 \\
			$\mathcal{S}_1$ & 3.69 & 2.93 & 3.86 & 2.97 \\
			$\mathcal{S}_2$ & 4.07 & 3.01 & 4.09 & 2.97 \\
			$\mathcal{S}_3$ & 4.07 & 3.07 & 3.89 & 2.90 \\
			$\mathcal{S}_4$ & 3.90 & 3.31 & 4.06 & 3.32 \\
			\cmidrule(lr){1-5}
			                & 3.86 & 3.05 & 3.90 & 3.02 \\
			\bottomrule
		\end{tabular}
		\caption{Cross validated mean and standard deviation of the absolute error for the age regressor model, comparing absolute and squared loss objectives.}
		\label{tab:regcrossval}
	\end{center}
\end{table}

\begin{comment}
\subsection*{Leave One Visit Out}
Given that the age regressor is exclusively utilized to estimate relative age differences in our generative model, we perform an additional experiment more directly focussed at that metric. To that end, we train the same model architecture for 100'000 batches of 32 images each from the Leave One Visit Out data set outlined in \autoref{sec:datloo}. We obtain a mean absolute validation error of 1.01 years which, while significanlty lower than the mean absolute error on a single image, is still relatively large considering the simplified problem setting. However, the value is similar to the loss in the pair time step setting as expected.
\end{comment}

\section{Diagnosis Classifier}
\label{sec:expdxclf}
We pre-train a diagnosis classifier to discriminate between images labeled as MCI and AD respectively. Given the gradual transition between the two diagnoses, we use the \textit{MCI/AD Set} described in \autoref{sec:datmciad}, which limits our training and validation sets to a subset of images for which we have increased confidence in the diagnosis labels. Note that we exclude all subjects in the healthy control group HC and use a binary classifier focussing on the more subtle distinctions between the effects of MCI and AD.

The classifier is implemented as a 3D CNN identical in structure to the age regressor. Softmax cross entropy is used as the objective function and minimizes using the Adam optimizer with $\alpha = 0.0001, \beta_1 = 0.9, \beta_2 = 0.999$ and $\epsilon = 0.01$ for increased training stability.
We perform cross validation using the 5-fold data split. Due to high variance in the classifier's accuracy, we train the model five times for every fold in order to avoid suboptimal local minima and report the best results. Each training runs consists of 10'000 batches of 32 samples each.

\begin{table}[h]
	\begin{center}
		\begin{tabular}{c c c c c c c c c c c}
			\toprule
			\multirow{2}{*}{Split} & 
			\multicolumn{2}{c}{Run 1} & 
			\multicolumn{2}{c}{2} & 
			\multicolumn{2}{c}{3} & 
			\multicolumn{2}{c}{4} & 
			\multicolumn{2}{c}{5} \\
			\cmidrule(lr){2-3}
			\cmidrule(lr){4-5}
			\cmidrule(lr){6-7}
			\cmidrule(lr){8-9}
			\cmidrule(lr){10-11}
			 & acc & $\text{F}_1$ & acc & $\text{F}_1$ & acc & $\text{F}_1$ & acc & $\text{F}_1$ & acc & $\text{F}_1$ \\ 
			%------
			\cmidrule(lr){1-11}
			$\mathcal{S}_0$ & 68.58 & 66.76 & 69.08 & 66.76 & \textbf{70.74} & \textbf{69.50} & 67.81 & 65.39 & 63.74 & 63.51 \\
			$\mathcal{S}_1$ & \textbf{70.32} & \textbf{72.07} & 66.13 & 68.13 & 68.10 & 70.26 & 69.95 & 72.01 & 70.07 & 71.84 \\
			$\mathcal{S}_2$ & 67.33 & 70.24 & 67.56 & 69.58 & 65.33 & 67.97 & \textbf{67.78} & \textbf{69.79} & 64.89 & 67.76 \\
			$\mathcal{S}_3$ & \textbf{71.68} & \textbf{71.03} & 70.14 & 69.86 & 70.26 & 69.94 & 68.13 & 67.31 & 70.50 & 68.52 \\
			$\mathcal{S}_4$ & 66.71 & 67.60 & 66.58 & 67.59 & \textbf{69.97} & \textbf{70.59} & 68.15 & 68.56 & 64.88 & 64.28 \\
			%\cmidrule(lr){1-11}
			%                & 3.86 & 3.05 & 3.90 & 3.02 & & & & & & \\
			\bottomrule
		\end{tabular}
		\caption{Cross validated accuracy and $\text{F}_1$-score of our classifier models.}
		\label{tab:clfcrossval}
	\end{center}
\end{table} %TODO(too wide)

\section{Diffeomorphic Models}

\subsection{Voxelmorph}
To establish a baseline, we first train a variation of the Voxelmorph architecture described in \autoref{sec:vox} with minimal modifications to support the brain aging task. These modifications include removing the target image $y$ from the generator input as well as extending the scaling and squaring method to produce output deformations $\Phi^{(t)}$ for arbitrary $t$ as described in \autoref{sec:adaarbtimestep}. Regarding hyperparameters, we use $\lambda = 25$ as suggested in \cite{dalca2018unsupervised} and reduce $\sigma$ to $0.01$ to account for the smaller magnitude of the changes in the brain aging setting discussed in \autoref{sec:ada}.

\subsection{Synthetic Data}
To validate our modifications to the architecture, we first train the model on 1'000 batches of 4 samples each from the synthetic data set described in \autoref{sec:datsynth}. Visual inspection of the results, presented in \autoref{fig:toydata} confirms the model's ability to learn and integrate over a stationary velocity field to generate deformation fields for variable time steps $t$. Furthermore, we demonstrate the effectiveness of the sparseness penalty in suppressing the deformation field in areas of little change. Note that neither the age regressor nor the diagnosis classifier are used in any of these experiments as there are no corresponding features in the synthetic data samples.

\begin{figure}
	%TODO(maybe flip time bar(
	\centering
	\input{tikz/toydata}
	\vspace*{-15pt}
	\caption{Model outputs generated using the synthetic data set. We train the model three times, on noisy or solid backgrounds, with or without applying a sparseness penalty. Each row represents one sample output consisting of the original, the target, and the generated image, the time step $t$ scaled to $[0, 1)$, the velocity field $v$ and its magnitude, as well as its separate dimensions. Note how the sparseness penalty leads to a more interpretable deformation field.}
	\label{fig:toydata}
\end{figure}

\subsection{MRI Data} %TODO(section title doesn't really make sense, more like adapted architecture, but then...)

We train the model in a number of different configurations and on different data sets listed in \autoref{tab:ganconfig}.

\begin{table}[h]
	\begin{center}
		\begin{tabular}{c c c c c c c}
			\toprule
			\# & $\lambda_{age}$ & $\lambda_{dx}$ &
				$\mathcal{S}_{train}$ & $\mathcal{S}_{valid}$ & $\mathcal{S}_{test}$ & Pairs \\
			%------
			\cmidrule(lr){1-7}
			1 &  -  &  -  & $\mathcal{S}_1\:\mathcal{S}_2\:\mathcal{S}_3\:\mathcal{S}_4$ &
				      $\mathcal{S}_0$ &
				      $\mathcal{S}_{test}$ &
				      \footnotesize any $\rightarrow$ any \\
			2 & 100 &  -  & $\mathcal{S}_1\:\mathcal{S}_3$ & 
				      $\mathcal{S}_2\:\mathcal{S}_4$ &
				      $\mathcal{S}_0$ & 
				      \footnotesize any $\rightarrow$ any \\
			3 &  -  & 100 & $\mathcal{S}_1\:\mathcal{S}_3$ & 
				      $\mathcal{S}_2\:\mathcal{S}_4$ &
				      $\mathcal{S}_{test}$ & 
				      \footnotesize any $\rightarrow$ MCI/AD \\
			4 & 100 & 100 & $\mathcal{S}_1\:\mathcal{S}_3$ & 
				      $\mathcal{S}_2\:\mathcal{S}_4$ &
				      $\mathcal{S}_0\:\mathcal{S}_{test}$ &
				      \footnotesize any $\rightarrow$ MCI/AD \\
			5 &  -  &  -  & $\mathcal{S}_1\:\mathcal{S}_2\:\mathcal{S}_3\:\mathcal{S}_4$ &
				      $\mathcal{S}_0$ &
				      - &
				      \footnotesize MCI/AD $\rightarrow$ AD \\
			6 &  -  &  -  & $\mathcal{S}_1\:\mathcal{S}_2\:\mathcal{S}_3\:\mathcal{S}_4$ &
				      $\mathcal{S}_0$ &
				      - &
				      \footnotesize HC $\rightarrow$ HC \\
			\bottomrule
		\end{tabular}
		\caption{Overview of the generator configurations.}
		\label{tab:ganconfig}
	\end{center}
\end{table}

For the remaining hyperparameters, we use an $L_1$ similarity loss of $\lambda_{sim} = 200$ and drop the sparseness loss altogether due to negative performance impacts even for small $\lambda_{sparse}$. During training, the velocity field $v$ is integrated using up to $T = 7$ squaring steps, resulting in a maximum number of $256$ atomic steps. In combination with the maximum time step of 6 years in our pairs data set, this corresponds to a temporal precision of 8.6 days.

Note that for the training of the regressor as well as the classifier used as loss terms in configurations 2, 3, and 4, $\mathcal{S}_{train}$ and $\mathcal{S}_{valid}$ are swapped. While this separation isn't required to ensure the validity of the results, a regressor or classifier pre-trained on the generator training data will predict age and diagnosis labels which are essentially identical to the real labels, therefore negating the error cancelling effect discussed in \autoref{sec:adaagereg}. Indeed, using this configuration results in impressive looking but overly confident results as seen in TODO(plot with slope 1)

The model is trained using the Adam optimizer with $\alpha = 0.0001$, $\beta_1 = 0.0$, $\beta_2 = 0.9$ and $\epsilon = 10^{-7}$. Limited by GPU memory, we use batch size of 8 and train the models for a varying number of steps depending on the configuration. Following the training procedure in \cite{goodfellow2014generative}, we alternate between training the critic and the generator on five and one batches respectively. Each such training step runs in roughly 5 seconds per batch or 0.6 seconds per sample.

\subsubsection*{Follow-Up Prediction}
As our first experiment, we use our model to predict follow-up images using the actual time steps in our pairs data set and evaluate the performance on this task on configurations 1 and 2.
We visually inspect the results
compare predicted time step

TODO(show example)

\begin{figure}[p]
	\centering
	\includegraphics[width=.7\linewidth]{images/age_plots/d_dhat_fake}
	\vspace*{-15pt}
	\caption{Age regressor estimates on 2651 validation samples $(x, \hat y)$ with $ \hat y = G(x) $ from our pairs data set, comparing the estimated age difference to the ground truth time step. Linear regression yields an intercept of X.XX and a slope of X.XX. Note that these results should be compared to the results on the real data in \autoref{fig:regddhatreal}.}
	\label{fig:regddhatfake}
\end{figure}

\subsubsection*{Fixed Time Step Prediction}
%TODO(predict brain at fixed time step)
To evaluate the model's ability to generate follow-up images at fixed time steps, we predict images at $t \in \{1, 2, 4, 6, 8\}$ years and estimate the age labels using the age regressor. The results for configurations 1 and 2 are presented in \autoref{tab:expfixed} and visualized for configuration 2 in \autoref{fig:expfixedhist}. Note that due to the age regressor's tendency to the mean, these results should be compared to \autoref{fig:regddhatreal} rather than the ground truth labels. We evaluate configuration 1 at 45'000 training steps, where the model converges, and configuration 2 at 15'000 steps where $\mathcal{L}_{age}$ is minimal on the validation data. 

While both configurations result in very similar predicted mean age, the standard deviation improves noticeably for configuration 2, indicating a positive effect of the age regressor loss term.

\begin{table}[h]
	\begin{center}
		\begin{tabular}{c c c c c c c c c c c}
			\toprule
			\multirow{2}{*}{\#} &
			\multicolumn{2}{c}{$t = 1$} &
			\multicolumn{2}{c}{2} &
			\multicolumn{2}{c}{4} &
			\multicolumn{2}{c}{6} &
			\multicolumn{2}{c}{8} \\
			\cmidrule(lr){2-3}
			\cmidrule(lr){4-5}
			\cmidrule(lr){6-7}
			\cmidrule(lr){8-9}
			\cmidrule(lr){10-11}
			 & $\mu$ & $\sigma$ & $\mu$ & $\sigma$ & $\mu$ & $\sigma$ & $\mu$ & $\sigma$ & $\mu$ & $\sigma$ \\
			%------
			\cmidrule(lr){1-11}
			1 & 1.90 & 0.95 & 2.60 & 1.36 & 3.30 & 2.24 & 3.51 & 3.01 & 3.35 & 3.69 \\
			2 & 1.93 & 0.85 & 2.64 & 1.11 & 3.24 & 1.67 & 3.53 & 2.22 & 3.62 & 2.79 \\
			\bottomrule
		\end{tabular}
		\caption{Mean and standard deviation of the estimated age labels on outputs generated for various different time steps.}
		\label{tab:expfixed}
	\end{center}
\end{table}

\begin{figure}
	\centering
	\includegraphics[width=\linewidth]{images/age_plots/hist_fixed}
	\vspace*{-15pt}
	\caption{TODO must be compared with slope.}
	\label{fig:expfixedhist}
\end{figure}

\subsubsection*{Feature Attribution}
To visualize the differences in aging between healthy subjects and subjects affected by Alzheimer's Disease, we train configurations 5 and 6 on data sets limited to healthysubjects and subjects diagnosed with Alzheimer's Disease respectively. We qualitatively observe higher mean deformation magnitudes for configuration 6 and visually compare the effects of the models applied to a healthy subject in \autoref{hcad_hc} and a subject affected by AD in \autoref{hcad_ad}. Configuration 6 produces more pronounced changes overall and most noticeably around the ventricles.
AD/HC only, compare
magnitude of flow differs (maybe numbers, but the finding is qualitative)

\begin{figure}
	\centering
	\includegraphics[width=\linewidth, trim={100 100 66 30}, clip]{images/HC_AD_plots/comp_ADNI_141445}
	\vspace*{-15pt}
	\caption{The center column consists of a series of real images from a \textbf{subject diagnosed with Alzheimer's Disease}, taken at one-year intervals steps, top to bottom. The two columns to the left show the predicted images at the same time steps using a model trained exclusively on healty patients, as well as the difference maps with respect to the base image. Similarly, the two columns to the right show the predicted images using a model exclusively trained on patients affected by Alzheimer's Disease.}
	\label{fig:hcad_ad} %TODO(tikz labels)
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=\linewidth, trim={100 100 66 30}, clip]{images/HC_AD_plots/comp_ADNI_137014}
	\vspace*{-15pt}
	\caption{The center column consists of a series of real images from a \textbf{healthy subject}, taken at one-year intervals steps, top to bottom. The two columns to the left show the predicted images at the same time steps using a model trained exclusively on healty patients, as well as the difference maps with respect to the base image. Similarly, the two columns to the right show the predicted images using a model exclusively trained on patients affected by Alzheimer's Disease.}
	\label{fig:hcad_hc} %TODO(tikz labels)
\end{figure}

%TODO(mean flow plots)

% pat_id:	n_imgs	field		remark	base_img

% AD:
% ADNI_1066	7	1.5	pMCI	bad	ADNI_85356
% ADNI_922	7	1.5	pMCI		ADNI_77852
% ADNI_1427	7	1.5	pMCI 		ADNI_153734
% ADNI_42	8	1.5	pMCI	ugly
% ADNI_214	7	1.5	pMCI		ADNI_137475	maybe
% ADNI_906	6	1.5	pMCI	nice	ADNI_120065	yes, for now
% ADNI_887	6	1.5	pMCI		ADNI_120099	really nice, but need better model
% ADNI_658	6	1.5	pMCI		ADNI_62841	nope
% ADNI_752	6	1.5	pMCI		ADNI_66508	almost no changes
% ADNI_331	6	1.5	pMCI		ADNI_141445	yes! but better model
% ADNI_1243	6	1.5	pMCI	nice	ADNI_214258	small changes, okay

% HC:
% ADNI_382	8	1.5			ADNI_107542	okay...
% ADNI_441	8	1.5			ADNI_104027	nope
% ADNI_553	9	1.5			ADNI_155040	real kinda okay, AD model bad
% ADNI_677	8	1.5			ADNI_116851	no, messed up real
% ADNI_303	6	1.5		ugly	
% ADNI_337	10	1.5			ADNI_142666	no, artifacts
% ADNI_298	9	1.5			ADNI_141972	real okay, small ventricles, maybe slice 20, but guess not
% ADNI_734	8	1.5			ADNI_116000	yes, for now, not great though
% ADNI_120	10	1.5			ADNI_137014	good, slice 15
% ADNI_260	9	1.5			ADNI_172291	not really, skull, workable if need be

\subsubsection*{Long-Term Prediction}
\label{sec:explongterm}
As mentioned in \autoref{sec:applongterm}, our model architecture allows generating images for very large time steps, such as 50 years, at reasonable computational cost. However, while the velocity field predicted by the generator is time-invariant in theory, its accuracy is highly dependent on the distribution of time steps occuring in the training data. In practice, using time steps around and beyond the maximum step in the training data very quickly result in unrealistic looking outputs. We generate images at time steps of $t \in \{2, 4, 6, 8, 10\}$ years for a random sample using configuration 1 and present the results in \autoref{fig:explongterm}.
Superior results could likely be obtained by using an iterative approach similar to \cite{wegmayr2019generative}, using multiple smaller time steps in sequence. TODO(fig)

\begin{figure}
	\centering
	\includegraphics[width=0.9\linewidth, trim={70 70 50 100}, clip]{images/age_plots/longterm_diff}
	\vspace*{-15pt}
	\caption{Sequence of base image and generated images for time steps of 2, 4, 6, 8 and 10 years, as well as the corresponding difference maps to the base image. We pick two samples which represent common outcomes in our data sets.}
	\label{fig:hcad_ad} %TODO(tikz labels)
\end{figure}

\subsubsection*{Conversion Prediction}
As described in \autoref{sec:appconvpred}, we evaluate the performance of our generative model on the MCI conversion prediction task. Given an image pair $(x, y)$ we generate $G(x)$ with time step $t = 4$ using our generative model and use a diagnosis classifier to predict $p_{AD}(G(x))$ and use thresholding to predict whether the subject is progressive or stable.

Keeping in mind the imbalanced nature of the conversion data set, we use balanced accuracy and $\text{F}_1$-score as our metrics

\begin{equation}
	acc = \frac{1}{2}\ \bigg(\frac{TP}{TP + FN} + \frac{TN}{TN + FP}\bigg)
\end{equation}

\begin{equation}
	\begin{split}
		\text{F}_1 =&\ 2\ \bigg(\frac{\text{precision} \cdot \text{recall}}{\text{precision} + \text{recall}}\bigg)
	\end{split}
\end{equation}
where
\begin{equation*}
	\begin{split}
	\text{precision} =& \ \frac{TP}{TP + FP} \\[8pt]
		\text{recall} =& \ \frac{TP}{TP + FN} \\[8pt]
	\end{split}
\end{equation*}
and $TP$ = true positives, $TN$ = true negatives, $FP$ = false positives and $FN$~=~false negatives.

Given a set of images $\{x\}$ from our conversion data set, we independently calculate the balanced conversion accuracy and the $\text{F}_1$-score as follows:
\begin{enumerate}
	\item We use a diagnosis classifier to predict the probabilities $p_{AD}(x)$ for each $x$
	\item We split the conversion data set into 5 balanced splits $\{\mathcal{T}_i\}_{i\ \in\ 0\ ..\ 4}$ and calculate $t_i$ for each split as the threshold which maximizes the target metric on $\{\mathcal{T}_j\}_{i \neq j}$.
	\item We calculate the metrics for each split $\mathcal{T}_i$ using the corresponding $t_i$ and take the mean over all splits
	\item We repeat steps 2 and 3 five times and take the mean for both metrics
	\item We repeat steps 1 to 4 for each of the five best classifier in \autoref{tab:clfcrossval} and again take the mean
\end{enumerate}

We calculate the balanced accuracy and $\text{F}_1$-score on the set of base images $x$ as a baseline and similarly on the set of target images $y$ as an upper bound. Finally, we calculate the metrics for our generated images $G(x)$ for TODO(which runs) and compare the results in TODO(table).

\begin{table}[h]
	\begin{center}
		\begin{tabular}{c c c c c c c c}
			\toprule
			\multirow{2}{*}{Config} & 
			\multicolumn{2}{c}{accuracy} &
			\multicolumn{5}{c}{Classifier} \\
			\cmidrule(lr){2-3}
			\cmidrule(lr){4-8}
			 & $\mu$ & $\sigma$ & 0 & 1 & 2 & 3 & 4 \\
			%------
			\cmidrule(lr){1-8}
			$y$ & 75.90 & 0.009 & 74.52 & 76.17 & 76.69 & 75.80 & 76.31 \\
			$x$ & 63.81 & 0.017 & 64.17 & 65.41 & 64.18 & 61.06 & 64.25 \\
			\cmidrule(lr){1-8}
			0   & 66.20 & 0.015 & 65.52 & 65.94 & 65.57 & 65.60 & 68.38 \\
			1   & 63.98 & 0.038 & 68.40 & 60.62 & 68.53 & 60.15 & 62.22 \\
			2   & 64.71 & 0.022 & 65.38 & 67.98 & 62.73 & 63.01 & 64.46 \\
			\cmidrule(lr){1-8}
					
			\bottomrule
		\end{tabular}
		\caption{Cross validated accuracy and $\text{F}_1$-score of our classifier models.}
		\label{tab:expconvresults}
	\end{center}
\end{table} %TODO(too wide)

%5x classifier, from cross val
%5x threshold each
%xr = baseline
%yr = upper bound

%F1 score, accuracy

\chapter{Discussion}
Architecture with many components, hard to pinpoint problem origin

Large number of hyperparameters, high training time

Interpretability of WGAN loss

Generative model output validation is hard, regressor as 
